name: Maintenance

on:
  schedule:
    # Run daily at 2:00 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      task:
        description: 'Maintenance task to run'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - security-scan
          - dependency-update
          - performance-test
          - cleanup

env:
  GO_VERSION: '1.19'

jobs:
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event.inputs.task == 'security-scan' || github.event.inputs.task == 'all' || github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run Gosec Security Scanner
        uses: securecodewarrior/github-action-gosec@master
        with:
          args: '-fmt sarif -out gosec.sarif ./...'

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: gosec.sarif

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check for vulnerabilities
        run: |
          echo "üîç Security scan completed"
          if [ -f gosec.sarif ]; then
            GOSEC_ISSUES=$(jq '.runs[0].results | length' gosec.sarif)
            echo "Gosec found $GOSEC_ISSUES potential security issues"
          fi
          
          if [ -f trivy-results.sarif ]; then
            TRIVY_ISSUES=$(jq '.runs[0].results | length' trivy-results.sarif)
            echo "Trivy found $TRIVY_ISSUES vulnerabilities"
          fi

  dependency-update:
    name: Dependency Update Check
    runs-on: ubuntu-latest
    if: github.event.inputs.task == 'dependency-update' || github.event.inputs.task == 'all' || github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Check for outdated dependencies
        run: |
          echo "üì¶ Checking for outdated dependencies..."
          
          # Get current dependencies
          go list -m -u all > current_deps.txt
          
          # Check for updates
          OUTDATED=$(go list -m -u all | grep -E '\[.*\]' || true)
          
          if [ -n "$OUTDATED" ]; then
            echo "‚ö†Ô∏è Outdated dependencies found:"
            echo "$OUTDATED"
            
            # Create issue for outdated dependencies
            cat > dependency_update_issue.md << EOF
          ## üì¶ Outdated Dependencies Detected
          
          The following dependencies have updates available:
          
          \`\`\`
          $OUTDATED
          \`\`\`
          
          ### Recommended Actions
          1. Review the changelog for each dependency
          2. Test updates in a development environment
          3. Update dependencies with \`go get -u\`
          4. Run full test suite to ensure compatibility
          
          ### Auto-generated by maintenance workflow
          Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          EOF
            
            echo "üìù Dependency update report generated"
          else
            echo "‚úÖ All dependencies are up to date"
          fi

      - name: Check Go version
        run: |
          echo "üîç Checking Go version..."
          CURRENT_GO=$(go version | awk '{print $3}' | sed 's/go//')
          LATEST_GO=$(curl -s https://golang.org/VERSION?m=text | sed 's/go//')
          
          echo "Current Go version: $CURRENT_GO"
          echo "Latest Go version: $LATEST_GO"
          
          if [ "$CURRENT_GO" != "$LATEST_GO" ]; then
            echo "‚ö†Ô∏è Go version $LATEST_GO is available (current: $CURRENT_GO)"
          else
            echo "‚úÖ Go version is up to date"
          fi

  performance-test:
    name: Performance Test
    runs-on: ubuntu-latest
    if: github.event.inputs.task == 'performance-test' || github.event.inputs.task == 'all' || github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Run performance tests
        run: |
          echo "‚ö° Running performance tests..."
          mkdir -p test_reports/benchmarks
          
          # Run benchmarks
          go test -bench=. -benchmem -count=3 -timeout=30m ./tests/... > test_reports/benchmarks/benchmark_results.txt 2>&1
          
          echo "üìä Performance test results:"
          cat test_reports/benchmarks/benchmark_results.txt

      - name: Analyze performance
        run: |
          echo "üìà Analyzing performance results..."
          
          if [ -f test_reports/benchmarks/benchmark_results.txt ]; then
            # Extract key metrics
            BENCHMARK_COUNT=$(grep -c "^Benchmark" test_reports/benchmarks/benchmark_results.txt || echo "0")
            echo "Total benchmarks run: $BENCHMARK_COUNT"
            
            # Check for performance regressions (simplified)
            if grep -q "FAIL" test_reports/benchmarks/benchmark_results.txt; then
              echo "‚ö†Ô∏è Some performance tests failed"
            else
              echo "‚úÖ All performance tests passed"
            fi
          fi

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results-${{ github.run_number }}
          path: test_reports/benchmarks/

  cleanup:
    name: Repository Cleanup
    runs-on: ubuntu-latest
    if: github.event.inputs.task == 'cleanup' || github.event.inputs.task == 'all' || github.event_name == 'schedule'
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clean up old workflow runs
        uses: actions/github-script@v6
        with:
          script: |
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            for (const workflow of workflows.workflows) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflow.id,
                status: 'completed',
                per_page: 100,
              });
              
              // Keep the latest 50 runs, delete older ones
              const runsToDelete = runs.workflow_runs.slice(50);
              
              for (const run of runsToDelete) {
                try {
                  await github.rest.actions.deleteWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id,
                  });
                  console.log(`Deleted workflow run ${run.id} from ${workflow.name}`);
                } catch (error) {
                  console.log(`Failed to delete run ${run.id}: ${error.message}`);
                }
              }
            }

      - name: Clean up old artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const { data: artifacts } = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            for (const artifact of artifacts.artifacts) {
              const createdAt = new Date(artifact.created_at);
              
              if (createdAt < thirtyDaysAgo) {
                try {
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id,
                  });
                  console.log(`Deleted artifact ${artifact.name} (${artifact.id})`);
                } catch (error) {
                  console.log(`Failed to delete artifact ${artifact.id}: ${error.message}`);
                }
              }
            }

      - name: Repository statistics
        run: |
          echo "üìä Repository Statistics:"
          echo "- Total files: $(find . -type f | wc -l)"
          echo "- Go files: $(find . -name "*.go" | wc -l)"
          echo "- Test files: $(find . -name "*_test.go" | wc -l)"
          echo "- Total lines of code: $(find . -name "*.go" -exec wc -l {} + | tail -1 | awk '{print $1}')"

  health-check:
    name: Repository Health Check
    runs-on: ubuntu-latest
    if: github.event.inputs.task == 'all' || github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check repository health
        run: |
          echo "üè• Repository Health Check"
          
          # Check for required files
          REQUIRED_FILES=(
            "README.md"
            "LICENSE"
            "go.mod"
            "go.sum"
            "Dockerfile"
            "docker-compose.yml"
            ".gitignore"
            "Makefile"
          )
          
          echo "üìã Checking required files:"
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "‚úÖ $file"
            else
              echo "‚ùå $file (missing)"
            fi
          done
          
          # Check for documentation
          echo ""
          echo "üìö Documentation check:"
          if [ -f "TESTING.md" ]; then
            echo "‚úÖ Testing documentation"
          else
            echo "‚ùå Testing documentation (missing)"
          fi
          
          if [ -f "CONTRIBUTING.md" ]; then
            echo "‚úÖ Contributing guidelines"
          else
            echo "‚ö†Ô∏è Contributing guidelines (recommended)"
          fi
          
          # Check for security files
          echo ""
          echo "üîí Security files check:"
          if [ -f "SECURITY.md" ]; then
            echo "‚úÖ Security policy"
          else
            echo "‚ö†Ô∏è Security policy (recommended)"
          fi
          
          if [ -f ".github/dependabot.yml" ]; then
            echo "‚úÖ Dependabot configuration"
          else
            echo "‚ö†Ô∏è Dependabot configuration (recommended)"
          fi

      - name: Check code quality metrics
        run: |
          echo "üìä Code Quality Metrics:"
          
          # Count test coverage (approximate)
          GO_FILES=$(find . -name "*.go" -not -path "./vendor/*" | wc -l)
          TEST_FILES=$(find . -name "*_test.go" -not -path "./vendor/*" | wc -l)
          
          if [ $GO_FILES -gt 0 ]; then
            TEST_RATIO=$(echo "scale=2; $TEST_FILES * 100 / $GO_FILES" | bc -l)
            echo "- Test file ratio: ${TEST_RATIO}%"
          fi
          
          # Check for TODO/FIXME comments
          TODO_COUNT=$(grep -r "TODO\|FIXME" --include="*.go" . | wc -l)
          echo "- TODO/FIXME comments: $TODO_COUNT"
          
          # Check for large files
          LARGE_FILES=$(find . -name "*.go" -size +1000c | wc -l)
          echo "- Large Go files (>1KB): $LARGE_FILES"

  report:
    name: Generate Maintenance Report
    runs-on: ubuntu-latest
    needs: [security-scan, dependency-update, performance-test, cleanup, health-check]
    if: always() && (github.event.inputs.task == 'all' || github.event_name == 'schedule')
    steps:
      - name: Generate report
        run: |
          echo "üìã Maintenance Report - $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "=================================================="
          echo ""
          
          # Job status summary
          echo "üîç Job Status Summary:"
          echo "- Security Scan: ${{ needs.security-scan.result }}"
          echo "- Dependency Update: ${{ needs.dependency-update.result }}"
          echo "- Performance Test: ${{ needs.performance-test.result }}"
          echo "- Cleanup: ${{ needs.cleanup.result }}"
          echo "- Health Check: ${{ needs.health-check.result }}"
          echo ""
          
          # Overall status
          if [[ "${{ needs.security-scan.result }}" == "success" && 
                "${{ needs.dependency-update.result }}" == "success" && 
                "${{ needs.performance-test.result }}" == "success" && 
                "${{ needs.cleanup.result }}" == "success" && 
                "${{ needs.health-check.result }}" == "success" ]]; then
            echo "‚úÖ All maintenance tasks completed successfully"
          else
            echo "‚ö†Ô∏è Some maintenance tasks had issues - please review the logs"
          fi
          
          echo ""
          echo "üîó Workflow URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: Create maintenance issue (if needed)
        if: needs.security-scan.result == 'failure' || needs.dependency-update.result == 'failure' || needs.performance-test.result == 'failure'
        uses: actions/github-script@v6
        with:
          script: |
            const title = `üîß Maintenance Issues Detected - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## üîß Maintenance Report
            
            Automated maintenance workflow detected issues that require attention.
            
            ### Job Results
            - Security Scan: ${{ needs.security-scan.result }}
            - Dependency Update: ${{ needs.dependency-update.result }}
            - Performance Test: ${{ needs.performance-test.result }}
            - Cleanup: ${{ needs.cleanup.result }}
            - Health Check: ${{ needs.health-check.result }}
            
            ### Action Required
            Please review the [workflow logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) and address any issues found.
            
            ### Auto-generated
            This issue was automatically created by the maintenance workflow.
            Date: ${new Date().toISOString()}
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['maintenance', 'automated']
            });

  notify:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [security-scan, dependency-update, performance-test, cleanup, health-check, report]
    if: always()
    steps:
      - name: Maintenance summary
        run: |
          echo "üîß Maintenance workflow completed"
          echo "Trigger: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Task: ${{ github.event.inputs.task }}"
          fi
          echo "Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "Check the workflow logs for detailed results."